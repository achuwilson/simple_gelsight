#!/usr/bin/env python3

import cv2
import numpy as np
import urllib.request
import urllib
import time
import numpy as np
#import open3d 
import scipy, scipy.fftpack
from scipy.interpolate import griddata
import numpy
import math

import rospy
import math
import sys

from sensor_msgs.msg import PointCloud2
import std_msgs.msg
import sensor_msgs.point_cloud2 as pcl2
import sensor_msgs.msg as sensor_msgs
import std_msgs.msg as std_msgs

from get_image import imageReader

#initialize ROS Node
rospy.init_node('gelsight_pclpub1')
# the pointclould generated by Gelsight will be published as a PointCloud2 message with name "/gelsight_pcl"
pcl_pub = rospy.Publisher("/gelsight_pcl1", PointCloud2,queue_size=1)
pcl_pub2 = rospy.Publisher("/gelsight_pcl1fil", PointCloud2,queue_size=1)

#give time to roscore to make the connections
rospy.sleep(1.)

cam0=imageReader('http://raspberrypi.local:8088/stream')

r = rospy.Rate(60)
DEBUG =False
def poisson_reconstruct(grady, gradx, boundarysrc):
    # Laplacian
    gyy = grady[1:,:-1] - grady[:-1,:-1]
    gxx = gradx[:-1,1:] - gradx[:-1,:-1]
    f = numpy.zeros(boundarysrc.shape)
    f[:-1,1:] += gxx
    f[1:,:-1] += gyy

    # Boundary image
    boundary = boundarysrc.copy()
    boundary[1:-1,1:-1] = 0;

    # Subtract boundary contribution
    f_bp = -4*boundary[1:-1,1:-1] + boundary[1:-1,2:] + boundary[1:-1,0:-2] + boundary[2:,1:-1] + boundary[0:-2,1:-1]
    f = f[1:-1,1:-1] - f_bp

    # Discrete Sine Transform
    tt = scipy.fftpack.dst(f, norm='ortho')
    fsin = scipy.fftpack.dst(tt.T, norm='ortho').T

    # Eigenvalues
    (x,y) = numpy.meshgrid(range(1,f.shape[1]+1), range(1,f.shape[0]+1), copy=True)
    denom = (2*numpy.cos(math.pi*x/(f.shape[1]+2))-2) + (2*numpy.cos(math.pi*y/(f.shape[0]+2)) - 2)

    f = fsin/denom

    # Inverse Discrete Sine Transform
    tt = scipy.fftpack.idst(f, norm='ortho')
    img_tt = scipy.fftpack.idst(tt.T, norm='ortho').T

    # New center + old boundary
    result = boundary
    result[1:-1,1:-1] = img_tt

    return result

def get_image_old():
    stream=urllib.request.urlopen('http://10.0.10.1:8080/?action=stream')
    bytess=b''
    while True:
        bytess+=stream.read(8192)
        a = bytess.find(b'\xff\xd8') # JPEG start
        b = bytess.find(b'\xff\xd9') # JPEG end
        if a!=-1 and b!=-1:
            jpg = bytess[a:b+2] # actual image
            bytess= bytess[b+2:] # other informations

            img = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8),cv2.IMREAD_COLOR) 
            #img = img[:,:,::-1]
            img = img[45:185, 20:300]
            return img
#cap =  cv2.VideoCapture('vid.mp4')            
def get_image2():
    ret,frame =  cap.read()
    if ret ==True:
        frame = frame[45:185, 20:300]
        return frame
    
def get_image():
    return cam0.getFrame()


def scale(input_value, input_min, input_max, out_min, out_max):
    """ scale a value from one range to another
    """
    # Figure out how 'wide' each range is
    input_span = input_max - input_min
    output_span = out_max - out_min
    # Convert the left range into a 0-1 range (float)
    valuescaled = (input_value - input_min) / (input_span)
    # Convert the 0-1 range into a value in the right range.
    return out_min + (valuescaled * output_span)

def point_cloud_p(points, parent_frame):
    """ Creates a point cloud message.

    Args:
        points: Nx7 array of xyz positions (m) and rgba colors (0..1)
        parent_frame: frame in which the point cloud is defined

    Returns:
        sensor_msgs/PointCloud2 message

    """
    ros_dtype = sensor_msgs.PointField.FLOAT32
    dtype = np.float32
    itemsize = np.dtype(dtype).itemsize

    data = points.astype(dtype).tobytes()

    fields = [sensor_msgs.PointField(
        name=n, offset=i*itemsize, datatype=ros_dtype, count=1)
        for i, n in enumerate('xyzrgba')]

    header = std_msgs.Header(frame_id=parent_frame, stamp=rospy.Time.now())

    return sensor_msgs.PointCloud2(
        header=header,
        height=1,
        width=points.shape[0],
        is_dense=False,
        is_bigendian=False,
        fields=fields,
        point_step=(itemsize * 7),
        row_step=(itemsize * 7 * points.shape[0]),
        data=data
    )



img_init = get_image()

#vis = open3d.Visualizer()
#vis.create_window()
#point_cloud = open3d.PointCloud()

#point_cloud.points = open3d.Vector3dVector(points)
#vis.add_geometry(point_cloud)

n = int(280)
m = int(140)

x = np.arange(n)
y = np.arange(m)
X, Y = np.meshgrid(x,y)
# Z = (X ** 2 + Y ** 2) / 10
Z = np.sin(X)
points = np.zeros([n * m, 3])
X_scl = scale(X,0,279,0,0.057)
Y_scl = scale(Y,0,139,0,0.030)

points[:, 0] = np.ndarray.flatten(X_scl )
points[:, 1] = np.ndarray.flatten(Y_scl)
points[:, 2] = np.ndarray.flatten(Z)
#point_cloud.points = open3d.Vector3dVector(points)
#vis.add_geometry(point_cloud)

time = 0
t = 0
colors = np.ones([n*m,4])
#colors  =  np.array([0,0,0,1])
while True:
    img = get_image()
       
    


    red_diff = np.clip(img[:,:,2].astype(int)-img_init[:,:,2].astype(int),0,255)
    green_diff = np.clip(img[:,:,1].astype(int)-img_init[:,:,1].astype(int),0,255)#.astype(np.uint8)
    blue_diff = np.clip(img[:,:,0].astype(int)-img_init[:,:,0].astype(int),0,255)#.astype(np.uint8)


    rec_img = (poisson_reconstruct(red_diff-green_diff,blue_diff,np.zeros_like(green_diff))[::1,:])
 
    rec_img =  scale(rec_img,-600,600,0,255)
    print(rec_img.shape)
    z_val =  rec_img.flatten()
    #scale to mm
    z_scaled = scale(z_val,0.0, 255.0,0.0,0.003) 
    #z_scaled = np.clip(z_scaled,0,0.01)
    points[:, 2] = np.ndarray.flatten(z_scaled)
    THR=0.0016
    #print(z_scaled.min())
    pfilar =np.where(points[:,2]>THR)
    filpoints=points[pfilar]
    filpoints[:,2] = filpoints[:,2]+0.001

    #print(z_val.max(),z_scaled.max())
  
    #point_cloud.points = open3d.Vector3dVector(points) 
    #vis.update_geometry()
    #vis.poll_events()
    #vis.update_renderer()
    npgradx,npgrady= np.gradient(rec_img)
    npgrad = npgradx + npgrady
    npgrad = scale(npgrad,-15.0,15.0,0.0, 1.0)
    npgradf = np.ndarray.flatten(npgrad)

    colors[:,0]= npgradf
    colors[:,1]= npgradf
    colors[:,2]= npgradf
    colors[:,3]= npgradf

    #print(npgradf.max(), npgradf.min(),npgradf)
    #colors[:,0:4]= npgradf[0]


    pnt = np.hstack((points,colors))
    
    #header = std_msgs.msg.Header()
    #header.stamp = rospy.Time.now()
    #header.frame_id = 'pcl3'
    #scaled_polygon_pcl = pcl2.create_cloud_xyz32(header, filpoints)
    #pcl_pub.publish(scaled_polygon_pcl)
    header = std_msgs.Header()
    header.stamp = rospy.Time.now()
    header.frame_id = 'pcl1'
    filtered_pcl = pcl2.create_cloud_xyz32(header, filpoints)
    pcl_pub.publish(point_cloud_p(pnt,'/pcl1'))
    pcl_pub2.publish(filtered_pcl)
    if(DEBUG):
        blue = img.copy()
        blue[:,:,1]=0
        blue[:,:,2]=0
        red = img.copy()
        red[:,:,0]=0
        red[:,:,1]=0
        green = img.copy()
        green[:,:,0]=0
        green[:,:,2]=0    
        cv2.imshow("img",img)
        cv2.imshow("red",red)
        cv2.imshow("green",green)
        cv2.imshow("blue",blue)
        cv2.imshow("red_diff",red_diff.astype(np.uint8))
        cv2.imshow("green_diff",green_diff.astype(np.uint8))
        cv2.imshow("blue_diff",blue_diff.astype(np.uint8))
        cv2.imshow("rec",rec_img.astype(np.uint8))
        
        laplacian = cv2.Laplacian(rec_img,cv2.CV_64F,ksize =5)
        laplacian = scale(laplacian,-700,700,0,255)
        npgradx,npgrady= np.gradient(rec_img)
        npgrad = npgradx + npgrady
        npgrad = scale(npgrad,-20,20,0, 255)
        #print(npgrad.max(),npgrad.min())
        #laplacian = np.clip(laplacian,0, 255)
        #laplacian = cv2.convertScaleAbs(laplacian)
        #print(laplacian.max(), laplacian.min(),len(npgrad[0]),len(npgrad[2]))
        cv2.imshow("lap",laplacian.astype(np.uint8))
        cv2.imshow("npgrad",npgrad.astype(np.uint8))
        
        
        key = cv2.waitKey(1)
        if key == 27:
                exit(0)
        elif key==99:
            img_init = get_image()
                    
    
    r.sleep()
  
    
